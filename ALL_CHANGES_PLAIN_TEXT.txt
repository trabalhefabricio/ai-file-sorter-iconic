================================================================================
COMPREHENSIVE FORK CHANGES - PLAIN TEXT FOR AI AGENT
================================================================================

Repository: trabalhefabricio/ai-file-sorter-iconic
Original Fork: hyperfield/ai-file-sorter
Format: Plain text for direct AI agent consumption
Date: January 7, 2026

================================================================================
USAGE INSTRUCTIONS
================================================================================

Feed these prompts to an AI agent sequentially:
1. Section 1: Changed/Enhanced Features (modify existing code)
2. Section 2: Implemented New Features (reference)
3. Section 3: Optimization Recommendations (apply these improvements)
4. Section 4: Planned Features (future work)


================================================================================
COMPREHENSIVE CHANGES DOCUMENTATION - "I WANT" FORMAT
================================================================================


Purpose: This document provides a complete, ordered list of all changes made to this fork compared to the original hyperfield/ai-file-sorter repository. Each change is described in "I want" format suitable for feeding to AI agents for implementation.

Original Repository: https://github.com/hyperfield/ai-file-sorter
This Fork: https://github.com/trabalhefabricio/ai-file-sorter-iconic

Date Created: January 7, 2026
Last Updated: January 7, 2026

---


================================================================================
TABLE OF CONTENTS
================================================================================


1. Section 1: Changed/Enhanced Features from Original
2. Section 2: Implemented New Features
3. Section 3: Planned/To-Be-Implemented Features

---


================================================================================
SECTION 1: CHANGED/ENHANCED FEATURES FROM ORIGINAL
================================================================================


These are modifications and enhancements to existing functionality in the original fork.


================================================================================
1.1 WHITELIST SYSTEM - HIERARCHICAL MODE SUPPORT
================================================================================


I want the whitelist system to support TWO distinct operational modes: hierarchical mode and shared mode (classic), allowing users to choose how categories and subcategories are organized.

Detailed Requirements:
- I want the whitelist system to store a usehierarchical boolean flag for each whitelist entry
- I want hierarchical mode where each category has its own dedicated set of subcategories (e.g., "Code" category has "Python, JavaScript, C++" subcategories, while "Documents" category has "Reports, Invoices, Contracts" subcategories)
- I want shared mode (classic) where all categories share the same global pool of subcategories
- I want the WhitelistStore class to persist both modes in the whitelists.ini file
- I want the system to store hierarchical mappings using categorysubcategorymap (std::map<std::string, std::vector<std::string>>) where each category key maps to its specific subcategory vector
- I want the INI file format to include UseHierarchical=true/false for each whitelist
- I want hierarchical subcategories stored as separate keys like SubcategoriesCode, SubcategoriesDocuments, etc. in the INI file
- I want backward compatibility so existing whitelists without the hierarchical flag default to shared mode
- I want the WhitelistManagerDialog to include radio buttons for mode selection with labels "Hierarchical Mode (Each category has its own subcategories)" and "Shared Mode (All categories share subcategories)"
- I want the UI to dynamically show/hide the shared subcategories editor based on selected mode
- I want conversion functionality that allows users to migrate between modes with a confirmation dialog warning about potential data changes
- I want the hierarchical tree view to display categories as parent nodes with their specific subcategories as children in hierarchical mode
- I want the shared subcategories section to only appear in shared mode with a dedicated "Edit Shared Subcategories" button
- I want semicolon (;) as the primary separator for categories and subcategories in the INI file, with fallback to comma (,) for backward compatibility
- I want the joincsv function to use "; " (semicolon with space) when serializing lists to INI format
- I want a flattentolegacy() method that converts hierarchical whitelist structure to flat format for AI prompt compatibility by collecting all unique subcategories from all categories into a single shared pool

Technical Implementation Details:
- Location: app/lib/WhitelistStore.cpp and app/include/WhitelistStore.hpp
- Location: app/lib/WhitelistManagerDialog.cpp and app/include/WhitelistManagerDialog.hpp
- The WhitelistEntry struct must include: bool usehierarchical and std::map<std::string, std::vector<std::string>> categorysubcategorymap
- When loading whitelists, check for UseHierarchical key and populate categorysubcategorymap by reading Subcategories<CategoryName> keys
- When saving in hierarchical mode, write each category's subcategories to its own INI key
- The UI mode switch must trigger onmodechanged() slot that updates tree display and shows/hides appropriate controls
- The flattentolegacy() method implementation: check if usehierarchical is false (return early if already flat), clear categories and subcategories vectors, create a std::set<std::string> for unique subcategories, iterate through categorysubcategorymap adding each category to categories vector and all subcategories to the unique set, then convert the set to subcategories vector

Files Modified:
- app/lib/WhitelistStore.cpp (~300 lines)
- app/include/WhitelistStore.hpp 
- app/lib/WhitelistManagerDialog.cpp (~500 lines)
- app/include/WhitelistManagerDialog.hpp
- app/lib/WhitelistTreeEditor.cpp (new file, ~400 lines)
- app/include/WhitelistTreeEditor.hpp (new file)

---


================================================================================
1.2 WHITELIST SYSTEM - SEPARATOR CHANGE FOR CATEGORIES/SUBCATEGORIES
================================================================================


I want the whitelist storage format to use semicolon (;) as the primary separator for categories and subcategories instead of comma (,), while maintaining backward compatibility with existing comma-separated lists.

Detailed Requirements:
- I want the splitcsv function to first check for semicolons in the input string and use that as the delimiter if present
- I want comma-based splitting to remain as a fallback for loading old whitelist files
- I want the joincsv function to always output semicolon-separated lists ("; " with space after semicolon)
- I want this change to apply to both Categories and Subcategories fields in the whitelists.ini file
- I want trimming of whitespace from individual items after splitting regardless of delimiter used
- I want empty strings filtered out from the split results

Rationale: Semicolons provide clearer visual separation and reduce ambiguity when category names might naturally contain commas (e.g., "Work, Professional Documents" vs "Work; Professional Documents").

Technical Implementation Details:
- Location: app/lib/WhitelistStore.cpp in anonymous namespace
- The splitcsv function checks value.contains(';') first, then falls back to comma splitting
- The joincsv function uses list.join("; ") to create semicolon-separated output
- Both functions handle QString to std::string conversions properly

Files Modified:
- app/lib/WhitelistStore.cpp (lines 10-43 approximately)

---


================================================================================
1.3 CATEGORIZATION PROMPT - ENHANCED CONTEXT BUILDING
================================================================================


I want the categorization prompt sent to LLMs to be built from multiple context components in a specific, ordered manner, combining language preferences, whitelist constraints, consistency hints, and user profile information.

Detailed Requirements:
- I want the buildcombinedcontext function to assemble the final context string from multiple sources in this order:
  1. Category language context (if user selected non-English categorization)
  2. Whitelist context (if whitelist is enabled)
  3. Consistency hints (if consistency mode is enabled)
  4. User profile context (if user profiling is enabled) [to be implemented]
- I want each context block separated by double newlines ("\n\n") for clarity
- I want the function to only include non-empty context blocks
- I want buildwhitelistcontext() to generate a structured text block listing allowed categories and subcategories based on the active whitelist
- I want buildcategorylanguagecontext() to return language instruction text if user selected a non-English category language (e.g., "Assign categories in Spanish")
- I want formathintblock() to create consistency hints text showing previous categorization examples from the current session
- I want the context building to be logged at debug level showing the number of categories and subcategories being applied
- I want the final combined context passed to all LLM categorization calls through the consistencycontext parameter

Rationale: A well-structured context improves LLM categorization accuracy by providing clear constraints, examples, and language preferences without overwhelming the prompt.

Technical Implementation Details:
- Location: app/lib/CategorizationService.cpp
- Function: std::string buildcombinedcontext(const std::string& hintblock) const
- The function checks settings.getusewhitelist() before including whitelist block
- Debug logging shows: "Applying category whitelist (X cats, Y subs)"
- Consistency hints are collected via collectconsistencyhints() and formatted via formathintblock()
- The combined context is built once per file and reused for retries

Files Modified:
- app/lib/CategorizationService.cpp (lines 516-542 approximately)

---


================================================================================
1.4 GOOGLE GEMINI API INTEGRATION - COMPLETE IMPLEMENTATION
================================================================================


I want full support for Google Gemini API with intelligent rate limiting, adaptive timeout handling, and free-tier optimization, matching the quality and robustness of the existing OpenAI integration.

Detailed Requirements:
- I want a dedicated GeminiClient class implementing the ILLMClient interface for consistency with other LLM clients
- I want the Select LLM dialog to include a "Google Gemini (Gemini API key)" option alongside Local LLM and ChatGPT options
- I want separate UI fields for Gemini API key and Gemini model name (e.g., "gemini-1.5-flash", "gemini-1.5-pro", "gemini-2.0-flash-exp")
- I want the Settings class to store geminiapikey and geminimodel separately from OpenAI credentials
- I want intelligent rate limiting at 15 requests per minute (RPM) to respect Gemini's free tier limits
- I want adaptive timeout handling starting at 20 seconds and exponentially increasing up to 240 seconds for slow responses
- I want exponential backoff retry logic with delays of 2s, 4s, 8s, 16s for transient failures (429, 503 errors)
- I want persistent state tracking that saves rate limiter state to avoid quota exhaustion across app restarts
- I want proper error handling for Gemini-specific error codes: 429 (quota exceeded), 503 (service unavailable), 400 (invalid request), 401 (authentication failure)
- I want the GeminiClient to construct proper HTTP requests to https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={apikey}
- I want request bodies formatted as JSON with contents array containing parts with text fields
- I want response parsing that extracts text from the candidates[0].content.parts[0].text path
- I want graceful handling of safety blocks where Gemini refuses to respond, returning a default "Uncategorized" result
- I want token usage tracking integrated with APIUsageTracker for cost estimation
- I want configuration validation that checks API key format and model name before allowing usage
- I want user-friendly error messages that suggest solutions (e.g., "Check your API key", "Rate limit reached - waiting 60 seconds")

Technical Implementation Details:
- Location: app/lib/GeminiClient.cpp (~824 lines) and app/include/GeminiClient.hpp
- The class uses libcurl for HTTP requests with proper header setting (Content-Type: application/json, x-goog-api-key: {key})
- Rate limiting uses a token bucket algorithm tracking timestamps of last 15 requests
- Timeout starts at 20s and doubles on timeouts up to 240s maximum
- State file stored at {appdatadir}/geministate.json containing rate limiter timestamps and timeout values
- Response JSON parsed using jsoncpp library
- Error responses include status code, error message, and suggested retry behavior
- Integration with Settings via getgeminiapikey(), setgeminiapikey(), getgeminimodel(), setgeminimodel()

Files Modified/Created:
- app/lib/GeminiClient.cpp (NEW, ~824 lines)
- app/include/GeminiClient.hpp (NEW)
- app/lib/Settings.cpp (add Gemini getters/setters)
- app/include/Settings.hpp (add Gemini member variables)
- app/lib/LLMSelectionDialog.cpp (add Gemini UI option)
- app/include/LLMSelectionDialog.hpp (add Gemini UI elements)
- app/lib/CategorizationService.cpp (instantiate GeminiClient when selected)
- CHANGELOG.md (document feature addition in v1.5.0)
- README.md (add "Using your Google Gemini API key" section)

Configuration Format:
[LLM]
choice=gemini
geminiapikey=AIzaSy...
geminimodel=gemini-1.5-flash

Gemini API Request Format:
{
  "contents": [{
    "parts": [{
      "text": "Categorize this file: document.pdf\n\nAssign a category and subcategory..."
    }]
  }]
}

Gemini API Response Format:
{
  "candidates": [{
    "content": {
      "parts": [{
        "text": "Work Documents : Reports"
      }]
    }
  }]
}

---


================================================================================
1.5 DRY RUN MODE - ENHANCED PREVIEW DIALOG
================================================================================


I want an enhanced dry run/preview mode that shows a comprehensive From→To table displaying exactly how files will be organized before any actual moves occur, with the ability to toggle dry run on/off and persistent undo support.

Detailed Requirements:
- I want a checkbox labeled "Dry run (preview only, do not move files)" in the results dialog
- I want the preview to show a table with columns: File Name, Current Location (From), New Location (To), Category, Subcategory
- I want the From column to show the abbreviated source path (with ~/  for user home directory)
- I want the To column to show the complete destination path that will be created
- I want the table to support sorting by any column (file name, from, to, category, subcategory)
- I want the table to be read-only during dry run mode - no file movements occur
- I want a clear visual indicator (icon, color, or label) showing when dry run mode is active
- I want the "Confirm & Sort!" button text to change to "Preview Only (Dry Run Active)" when dry run is checked
- I want the button to be disabled or show a warning if user tries to confirm during dry run
- I want users to uncheck dry run and click confirm again to perform actual file movements
- I want the dry run state to be saved so users can close the dialog, review, and come back
- I want the DryRunPreviewDialog class to generate the preview table without touching any files
- I want statistics shown: X files will be moved, Y new folders will be created, Z GB total size
- I want conflict detection during preview (e.g., "file.txt already exists in destination")
- I want the preview to integrate with the existing persistent undo system

Rationale: Users need confidence before reorganizing hundreds or thousands of files. A comprehensive preview eliminates anxiety and prevents mistakes.

Technical Implementation Details:
- Location: app/lib/DryRunPreviewDialog.cpp and app/include/DryRunPreviewDialog.hpp
- Location: app/lib/CategorizationDialog.cpp (dry run checkbox handling)
- The preview dialog uses QTableWidget with 5 columns
- Path abbreviation via Utils::abbreviateuserpath() for From column
- Destination path construction via builddestinationpath() for To column
- Statistics calculated by iterating categorized files and summing sizes
- Conflict detection checks if destination file exists using std::filesystem::exists()
- Sorting enabled via table->setSortingEnabled(true)
- Modal dialog blocks until user unchecks dry run or cancels

Files Modified:
- app/lib/DryRunPreviewDialog.cpp (~300 lines)
- app/include/DryRunPreviewDialog.hpp
- app/lib/CategorizationDialog.cpp (add dry run checkbox and handler)
- app/include/CategorizationDialog.hpp (add dry run state variable)

---


================================================================================
1.6 PERSISTENT UNDO SYSTEM ENHANCEMENT
================================================================================


I want an enhanced undo system that persists the latest file sorting operation to disk, allowing users to undo their last sort even after closing the application or the categorization dialog, with best-effort restoration that handles conflicts gracefully.

Detailed Requirements:
- I want every successful file sorting operation to save a complete undo plan to disk before moving any files
- I want the undo plan stored as a JSON file containing: original paths, destination paths, timestamps, operation metadata
- I want the undo plan path stored in a SQLite database table undohistory with fields: undoid, planpath, description, timestamp, isundone
- I want the Edit menu to include "Undo Last Run" as the first menu item (before other actions)
- I want "Undo Last Run" to be enabled only when a valid undo plan exists
- I want the UndoManager class to handle plan saving, loading, and execution
- I want undo execution to be best-effort: files that were deleted, modified, or have conflicts are skipped with warnings
- I want a progress dialog during undo showing: "Restoring file X of Y: filename"
- I want undo execution to be atomic: either all non-conflicting files restore or none do
- I want clear user feedback: "Undo completed: X files restored, Y files skipped (conflicts)"
- I want the undo plan marked as isundone=1 after successful execution to prevent double-undo
- I want the undo plan file deleted after successful undo (optional, configurable)
- I want collision handling: if original location is occupied, skip that file with a logged warning
- I want the system to validate file integrity using stored hashes before undo (optional enhancement)
- I want keyboard shortcut Ctrl+Z (Cmd+Z on macOS) to trigger undo from main window
- I want recent undo operations listed in "Edit → Undo History" submenu (up to 10 most recent)

Undo Plan File Format (JSON):
{
  "version": "1.0",
  "timestamp": "2026-01-07 18:30:45",
  "operation": "categorizeandsort",
  "sourcefolder": "/home/user/Downloads",
  "files": [
    {
      "originalpath": "/home/user/Downloads/document.pdf",
      "destinationpath": "/home/user/Downloads/Work Documents/Reports/document.pdf",
      "filesize": 245760,
      "checksum": "a1b2c3d4...",
      "category": "Work Documents",
      "subcategory": "Reports"
    }
  ]
}

Technical Implementation Details:
- Location: app/lib/UndoManager.cpp and app/include/UndoManager.hpp
- Location: app/lib/MainAppEditActions.cpp (Edit menu actions)
- Undo plans stored in {appdatadir}/undoplans/undo{timestamp}.json
- Database table: CREATE TABLE undohistory (undoid INTEGER PRIMARY KEY AUTOINCREMENT, planpath TEXT, description TEXT, timestamp DATETIME, isundone INTEGER DEFAULT 0)
- UndoManager methods: saveundoplan(), loadlatestundoplan(), executeundo(), getundohistory()
- File restoration uses std::filesystem::rename() with error handling for conflicts
- Progress reported via callback: [UNDO] Restoring: filename (X/Y)
- Keyboard shortcut connected via QAction with QKeySequence::Undo

Files Modified:
- app/lib/UndoManager.cpp (~400 lines enhancement)
- app/include/UndoManager.hpp
- app/lib/MainAppEditActions.cpp (add undo menu action)
- app/lib/ResultsCoordinator.cpp (save undo plan before sorting)
- app/lib/DatabaseManager.cpp (add undohistory table, CRUD methods)

---



================================================================================
SECTION 2: IMPLEMENTED NEW FEATURES
================================================================================


These are entirely new features that don't exist in the original fork.


================================================================================
2.1 USER PROFILING & ADAPTIVE LEARNING SYSTEM
================================================================================


I want a comprehensive user profiling system that learns from my file organization patterns over time, builds a detailed user profile, and uses this profile to provide increasingly personalized file categorization suggestions.

Detailed Requirements:


--------------------------------------------------------------------------------
CORE PROFILE BUILDING
--------------------------------------------------------------------------------

- I want automatic analysis of every folder I organize to extract insights about my interests, work patterns, and organizational style
- I want the system to infer user characteristics from file categories: hobbies (e.g., Music, Photography, Gaming), work patterns (e.g., frequent Document/Report categorization), organizational preferences (minimalist vs detailed)
- I want confidence scores for each characteristic that increase as more evidence accumulates (e.g., Music hobby confidence starts at 0.3 after 3 music files, increases 0.05 per folder with music)
- I want characteristics stored in database table userprofiles with fields: profileid, profilename, isactive, createdat, lastupdated
- I want detailed characteristics stored in profilecharacteristics table with: traitname, value, confidence, evidence, timestamp
- I want three types of characteristics tracked: Hobbies & Interests, Work & Professional, Organization Style
- I want the system to detect organizational styles: "Minimalist" (<5 categories used), "Balanced" (5-15 categories), "Detailed" (15-25 categories), "Power User" (>25 categories)


--------------------------------------------------------------------------------
FOLDER INSIGHTS TRACKING
--------------------------------------------------------------------------------

- I want detailed per-folder insights stored including: folder path, analysis date, total files analyzed, dominant categories, category distribution, file type breakdown
- I want folder insights stored in a separate database table linked to user profiles
- I want insights to show which categories dominate each folder (e.g., "Downloads: 60% Downloads, 25% Documents, 15% Media")
- I want temporal tracking showing how folder organization evolves over time
- I want insights used to recommend organization strategies for similar folders


--------------------------------------------------------------------------------
PROFILE-DRIVEN CATEGORIZATION
--------------------------------------------------------------------------------

- I want the user profile automatically passed to the LLM as context during categorization
- I want the profile context to include: top hobbies (max 5), work domain, organizational style, frequently used categories (max 10)
- I want the profile context formatted as natural language: "User Profile: Primary interests include music production and photography. Organizational style is detailed (20+ categories). Frequently uses: Music, Photos, Work Documents, Code, Archives."
- I want the LLM to use this context to make better categorization decisions aligned with user preferences
- I want profile-based categorization to be toggleable via "Learn from my organization patterns" checkbox on main screen


--------------------------------------------------------------------------------
PER-FOLDER LEARNING CONTROLS
--------------------------------------------------------------------------------

- I want per-folder learning level configuration: Full, Partial, or None
- I want "Full Learning" (default) to use profile for AI categorization AND store folder insights
- I want "Partial Learning" to skip profile usage but STILL store folder information for future profile building
- I want "No Learning" (None) to completely exclude the folder from profiling - no profile usage, no data storage
- I want a settings icon (⚙️) next to folder path input that opens FolderLearningDialog
- I want the dialog to show: folder path, current learning level (dropdown), explanation of each level, "Save" and "Cancel" buttons
- I want learning level stored in database table folderlearningsettings with fields: folderpath, learninglevel, updatedat


--------------------------------------------------------------------------------
PROFILE VISUALIZATION
--------------------------------------------------------------------------------

- I want a "View User Profile" menu item under Help menu
- I want UserProfileDialog showing three tabs: Overview, Characteristics, Folder Insights
- I want Overview tab showing: profile statistics (total files organized, folders analyzed, confidence level), top characteristics (top 5), organizational style summary
- I want Characteristics tab showing: grouped list by type (Hobbies, Work, Style), each characteristic with name, confidence bar (0-100%), evidence count, last updated timestamp
- I want Folder Insights tab showing: table of analyzed folders with columns (Folder Path, Date, Files, Dominant Category, Distribution %), sortable columns, "Remove" button to delete folder from history
- I want confidence bars color-coded: <40% red, 40-70% yellow, >70% green
- I want tooltips showing evidence examples: "Based on 12 folders containing Music files"


--------------------------------------------------------------------------------
PROFILE EVOLUTION & LEARNING
--------------------------------------------------------------------------------

- I want characteristic confidence to evolve: new characteristic starts at base confidence (0.3 for hobbies, 0.4 for work), confidence increases by increment per supporting folder (0.05 for hobbies, 0.03 for work), confidence decreases slowly if not reinforced (decay factor)
- I want conflicting evidence handled: if user stops using a category, confidence decreases over time
- I want the system to detect new interests automatically: organizing 3+ folders with new category type triggers new hobby/interest detection
- I want profile resets: "Clear Profile Data" button in profile dialog with confirmation prompt
- I want profile export/import for backup and migration: Export as JSON with all characteristics and folder insights


--------------------------------------------------------------------------------
PRIVACY & CONTROL
--------------------------------------------------------------------------------

- I want all profile data stored locally in SQLite database - NO cloud storage
- I want clear UI indicators when profile learning is active: checkbox checked on main window, learning level shown next to folder path
- I want complete transparency: users can see exactly what data is collected in profile dialog
- I want easy opt-out: unchecking "Learn from my organization patterns" disables all profile usage but preserves existing data
- I want per-folder granularity: sensitive folders can be set to "None" learning level independently

Technical Implementation Details:
- Location: app/lib/UserProfileManager.cpp (~657 lines) and app/include/UserProfileManager.hpp
- Location: app/lib/UserProfileDialog.cpp (~400 lines) and app/include/UserProfileDialog.hpp
- Location: app/lib/FolderLearningDialog.cpp (NEW) and app/include/FolderLearningDialog.hpp (NEW)
- Database tables: userprofiles, profilecharacteristics, folderinsights, folderlearningsettings
- Integration: UserProfileManager called by CategorizationService after successful categorization
- Profile context injected into LLM prompt via buildprofilecontext() method
- Confidence calculation constants in anonymous namespace: kMinHobbyConfidence = 0.3f, kConfidenceIncrement = 0.05f, kMinFilesForHobby = 3

Database Schema:
CREATE TABLE userprofiles (
    profileid INTEGER PRIMARY KEY AUTOINCREMENT,
    profilename TEXT UNIQUE NOT NULL,
    isactive INTEGER DEFAULT 1,
    createdat DATETIME,
    lastupdated DATETIME
);

CREATE TABLE profilecharacteristics (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    profileid INTEGER,
    characteristictype TEXT, -- 'hobby', 'work', 'style'
    traitname TEXT,
    value TEXT,
    confidence REAL,
    evidencecount INTEGER,
    lastreinforced DATETIME,
    FOREIGN KEY(profileid) REFERENCES userprofiles(profileid)
);

CREATE TABLE folderinsights (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    profileid INTEGER,
    folderpath TEXT,
    analysisdate DATETIME,
    totalfiles INTEGER,
    dominantcategory TEXT,
    categorydistribution TEXT, -- JSON
    filetypebreakdown TEXT, -- JSON
    FOREIGN KEY(profileid) REFERENCES userprofiles(profileid)
);

CREATE TABLE folderlearningsettings (
    folderpath TEXT PRIMARY KEY,
    learninglevel TEXT, -- 'full', 'partial', 'none'
    updatedat DATETIME
);

Profile Context Example:
User Profile Context:
- Primary interests: Music Production, Photography, Gaming
- Work domain: Software Development
- Organizational style: Detailed (uses 23 categories on average)
- Frequently used categories: Code, Documents, Music, Photos, Downloads, Projects, Archives, Videos, Books, Work Documents
- Profile confidence: 78% (based on 15 folders analyzed)

Files Modified/Created:
- app/lib/UserProfileManager.cpp (NEW, ~657 lines)
- app/include/UserProfileManager.hpp (NEW)
- app/lib/UserProfileDialog.cpp (NEW, ~400 lines)
- app/include/UserProfileDialog.hpp (NEW)
- app/lib/FolderLearningDialog.cpp (NEW, ~200 lines)
- app/include/FolderLearningDialog.hpp (NEW)
- app/lib/DatabaseManager.cpp (add profile tables and CRUD methods)
- app/lib/CategorizationService.cpp (integrate profile context into prompts)
- app/lib/MainApp.cpp (add "Learn from my organization patterns" checkbox, folder settings icon, Help menu item)
- app/lib/MainAppHelpActions.cpp (add "View User Profile" action)
- README.md (add "User Profiling & Adaptive Learning" section)

---


================================================================================
2.2 DATABASE CACHE MANAGER DIALOG
================================================================================


I want a comprehensive cache management dialog accessible from Settings menu that allows me to view cache statistics, clear cache selectively or completely, optimize the database, and understand cache behavior.

Detailed Requirements:
- I want a menu item "Settings → Manage Cache..." that opens CacheManagerDialog
- I want the dialog to display real-time cache statistics: Total entries count, Total cache size in MB, Oldest entry date, Newest entry date, Cache hit rate (if tracked)
- I want a "Refresh Statistics" button that updates all statistics without closing the dialog
- I want a "Clear All Cache" button with confirmation dialog ("This will delete all X cached categorizations. Continue?")
- I want a "Clear Old Cache" section with a spinbox for days (default 90) and "Clear" button that deletes entries older than specified days
- I want an "Optimize Database" button that runs SQLite VACUUM command to reclaim space and defragment
- I want the optimize operation to show progress: "Optimizing database..." with hourglass cursor
- I want clear feedback after each operation: "Cache cleared: X entries removed", "Database optimized: Y MB reclaimed"
- I want the cache statistics to show the breakdown: X files from cache (hit), Y files from LLM (miss)
- I want folder-specific cache clearing: dropdown to select folder, button to clear cache only for that folder
- I want the dialog to update statistics automatically after any clear operation
- I want all operations to be non-destructive to the database structure - only data is affected
- I want a warning shown if cache is large (>100MB): "Large cache detected. Consider clearing old entries."

Technical Implementation Details:
- Location: app/lib/CacheManagerDialog.cpp (~212 lines) and app/include/CacheManagerDialog.hpp
- Statistics queries: SELECT COUNT() FROM filecategorization, SELECT SUM(length(category) + length(subcategory))  0.001 FROM filecategorization for size estimate
- Date queries: SELECT MIN(datetime), MAX(datetime) FROM filecategorization WHERE datetime IS NOT NULL
- Clear operations: DELETE FROM filecategorization WHERE datetime < date('now', '-X days')
- Optimize: db.exec("VACUUM") followed by size comparison
- Modal dialog with QVBoxLayout containing statistics labels, buttons, and result text edit

Files Modified/Created:
- app/lib/CacheManagerDialog.cpp (NEW, ~212 lines)
- app/include/CacheManagerDialog.hpp (NEW)
- app/lib/MainApp.cpp (add Settings menu item)
- app/lib/DatabaseManager.cpp (add getcachestatistics(), clearcacheolderthan(), optimizedatabase() methods)

---


================================================================================
2.3 API USAGE TRACKING & STATISTICS DISPLAY
================================================================================


I want comprehensive tracking of all API usage (OpenAI and Gemini) with cost estimation, quota monitoring, and visual usage statistics, accessible from the Tools menu.

Detailed Requirements:


--------------------------------------------------------------------------------
API USAGE TRACKING BACKEND
--------------------------------------------------------------------------------

- I want automatic tracking of every API request made to OpenAI or Gemini
- I want the APIUsageTracker class to record: provider name, date, tokens used, request count, model name, estimated cost
- I want database table apiusagetracking with fields: id, provider, date, model, tokensused, requestsmade, costestimate, timestamp
- I want real-time tracking: each LLM request immediately logged before returning results
- I want token counting for OpenAI based on response headers (x-openai-usage header)
- I want request counting for Gemini (free tier: 15 RPM, 1500 RPD limits)
- I want cost estimation based on configurable model pricing: stored in modelcosts table or config file
- I want daily aggregation: new record created per day per provider
- I want automatic rollover at midnight (UTC)


--------------------------------------------------------------------------------
COST ESTIMATION
--------------------------------------------------------------------------------

- I want cost calculated as: (tokensused / 1000)  costper1ktokens
- I want default pricing: gpt-4o-mini $0.15/1M input + $0.60/1M output, gemini-1.5-flash FREE (with quota), gemini-1.5-pro $0.35/1M input + $1.40/1M output
- I want pricing configurable via settings file: appdata/modelpricing.json
- I want separate tracking for input vs output tokens where available
- I want monthly cost estimates: sum of daily costs for current month
- I want year-to-date totals


--------------------------------------------------------------------------------
QUOTA MONITORING
--------------------------------------------------------------------------------

- I want Gemini free tier quota tracked: 15 RPM (requests per minute), 1500 RPD (requests per day), 1500 RPD (requests per month on free tier)
- I want quota reset tracking: RPM resets every 60 seconds, RPD resets at UTC midnight, monthly resets on 1st of month
- I want remaining quota displayed: "Remaining today: X/1500 requests"
- I want warnings when approaching limits: at 80% show yellow warning, at 95% show red warning
- I want visual progress bars showing quota usage with color coding


--------------------------------------------------------------------------------
USAGE STATISTICS DIALOG
--------------------------------------------------------------------------------

- I want "Tools → API Usage Statistics" menu item opening UsageStatsDialog
- I want the dialog to show multiple tabs: Today, This Month, Historical, Charts
- I want Today tab showing: Provider breakdown, Tokens used today (OpenAI), Requests made today (Gemini), Estimated cost today, Remaining free quota (Gemini), Last request timestamp
- I want This Month tab showing: Total tokens/requests by provider, Total estimated cost, Daily average, Most active day, Cost breakdown by model
- I want Historical tab showing: Table of all daily records (date, provider, tokens/requests, cost), sortable columns, date range filter, export to CSV button
- I want Charts tab showing: Line chart of daily token usage over last 30 days, Bar chart of cost per day, Pie chart of provider distribution
- I want all statistics to refresh automatically when dialog is opened
- I want a "Refresh" button to manually reload latest data
- I want color-coded quota indicators: <50% green, 50-80% yellow, 80-95% orange, >95% red


--------------------------------------------------------------------------------
VISUAL ELEMENTS
--------------------------------------------------------------------------------

- I want quota progress bars with labels: "[███████░░░] 70% (1050/1500 requests)"
- I want cost displayed with currency: "$2.45" or "$0.00 (Free tier)"
- I want sparklines showing 7-day trend next to today's stats
- I want clear distinction between free (Gemini) and paid (OpenAI) services
- I want tooltips explaining each metric: "Tokens: Number of input + output tokens processed by OpenAI"

Technical Implementation Details:
- Location: app/lib/APIUsageTracker.cpp (~124 lines) and app/include/APIUsageTracker.hpp
- Location: app/lib/UsageStatsDialog.cpp (~400 lines) and app/include/UsageStatsDialog.hpp
- Integration: CategorizationService calls apitracker.recordrequest() after each successful LLM call
- Database: CREATE TABLE apiusagetracking (id INTEGER PRIMARY KEY AUTOINCREMENT, provider TEXT, date DATE, model TEXT, tokensused INTEGER, requestsmade INTEGER, costestimate REAL, timestamp DATETIME)
- Charts use Qt Charts library: QLineSeries for line charts, QBarSeries for bar charts, QPieSeries for pie charts
- Export uses QTextStream writing CSV format

Files Modified/Created:
- app/lib/APIUsageTracker.cpp (NEW, ~124 lines)
- app/include/APIUsageTracker.hpp (NEW)
- app/lib/UsageStatsDialog.cpp (NEW, ~400 lines)
- app/include/UsageStatsDialog.hpp (NEW)
- app/lib/DatabaseManager.cpp (add apiusagetracking table, aggregation queries)
- app/lib/LLMClient.cpp (integrate usage tracking)
- app/lib/GeminiClient.cpp (integrate usage tracking with quota checks)
- app/lib/MainApp.cpp (add Tools menu item)
- README.md (add API Usage Tracking section)

---


================================================================================
2.4 FILE TINDER TOOL - SWIPE-STYLE FILE CLEANUP
================================================================================


I want a fun, efficient file cleanup tool (File Tinder) accessible from Tools menu that lets me quickly review files one-by-one using keyboard shortcuts and decide whether to keep or delete them, with file previews and session persistence.

Detailed Requirements:


--------------------------------------------------------------------------------
CORE FUNCTIONALITY
--------------------------------------------------------------------------------

- I want a "Tools → File Tinder" menu item that opens FileTinderDialog with folder selection
- I want files presented one at a time in a large central area with big, clear buttons
- I want keyboard shortcuts for rapid decisions: → (Right Arrow) = Keep file, ← (Left Arrow) = Delete file, ↓ (Down Arrow) = Skip file, ↑ (Up Arrow) = Go back to previous file
- I want visual feedback for each action: button highlights, transition animations
- I want decisions tracked but NOT executed until final review
- I want a progress indicator: "File X of Y" with percentage
- I want real-time decision counters: "Keep: 45 | Delete: 23 | Skip: 12"
- I want session persistence: if I close dialog mid-session, I can resume later from same file
- I want final review dialog showing all marked-for-deletion files before actual deletion occurs
- I want batch deletion with confirmation: "Delete 23 files? This cannot be undone."
- I want undo support: mark files for deletion in database, execute deletion as batch, save undo plan


--------------------------------------------------------------------------------
FILE PREVIEW CAPABILITIES
--------------------------------------------------------------------------------

- I want different preview types based on file type: Images: Show thumbnail or full preview with zoom, Text files (.txt, .md, .log): Show first 100 lines with syntax highlighting, PDFs: Show first page or filename + metadata, Videos: Show first frame thumbnail + duration + resolution, Archives (.zip, .rar, .7z): Show list of contents, Folders: Show tree view of immediate contents, Code files: Show first 50 lines with language detection, Other: Show file metadata (size, type, dates)
- I want preview area to be responsive: resize to fit large images, scroll for long text
- I want fallback preview: if preview generation fails, show filename, size, type, and modification date
- I want image zoom controls: mouse wheel to zoom, drag to pan
- I want "Open in External Viewer" button to launch file in default application


--------------------------------------------------------------------------------
DECISION HISTORY & STATISTICS
--------------------------------------------------------------------------------

- I want all decisions stored in database table filetinderstate with fields: folderpath, filepath, decision, timestamp
- I want decision persistence across sessions: closing and reopening dialog resumes from last file
- I want session statistics: Time spent, Files reviewed, Decisions made, Average time per file
- I want end-of-session summary: "Session complete! Keep: 45, Delete: 23, Skip: 12, Time: 15m"
- I want filter options: File type dropdown (All, Images, Documents, Videos, etc.), Size filter (>10MB, >100MB), Date filter (Older than X days)


--------------------------------------------------------------------------------
ENHANCED FEATURES
--------------------------------------------------------------------------------

- I want an optional 5-second timeout per file (toggleable): If no decision made within 5 seconds, file automatically moves to back of queue
- I want timeout indicator: Circular progress ring showing countdown
- I want "Pause" button to suspend timeout and allow careful review
- I want "Mark for Review" option (Shift+↓): Files marked for review are set aside for detailed inspection later
- I want favorite files: Ctrl+F to mark favorites, saved to favorites list
- I want bulk actions: "Mark all remaining as Keep/Delete/Skip"


--------------------------------------------------------------------------------
SAFETY FEATURES
--------------------------------------------------------------------------------

- I want deletion preview: Show total size of files to be deleted before confirmation
- I want protected file warnings: System files, files currently open, files larger than 1GB get extra confirmation
- I want deletion dry run: Option to simulate deletion without actually deleting
- I want undo support: Deleted files saved in trash/recycle bin for 30 days (platform-dependent)
- I want warning on accidental close: "You have unsaved decisions. Close anyway?"

Technical Implementation Details:
- Location: app/lib/FileTinderDialog.cpp (~540 lines) and app/include/FileTinderDialog.hpp
- Files loaded via FileScanner class, stored in std::vector<FileToReview>
- Current index tracked: sizet currentindex pointing to current file
- Preview generation uses Qt image loading: QImage, QPixmap, QTextEdit for text, QProcess for external preview generators
- Decision enum: enum class Decision { Keep, Delete, Skip, Pending }
- Keyboard events handled via keyPressEvent() override
- Database: CREATE TABLE filetinderstate (id INTEGER PRIMARY KEY AUTOINCREMENT, folderpath TEXT, filepath TEXT, decision TEXT, timestamp DATETIME)
- Session save/load: Write current index and decisions to database, reload on next launch
- Deletion executor: Batch std::filesystem::remove() calls with error handling

Files Modified/Created:
- app/lib/FileTinderDialog.cpp (NEW, ~540 lines)
- app/include/FileTinderDialog.hpp (NEW)
- app/lib/DatabaseManager.cpp (add filetinderstate table, CRUD methods)
- app/lib/MainApp.cpp (add Tools menu item)
- README.md (add File Tinder section with keyboard shortcuts table)

UI Layout:
┌─────────────────────────────────────────────┐
│ File Tinder - Quick File Cleanup            │
├─────────────────────────────────────────────┤
│  [Progress: 45/120 (37.5%)]                 │
│  Keep: 25 | Delete: 15 | Skip: 5            │
├─────────────────────────────────────────────┤
│                                              │
│         [Large File Preview Area]            │
│             filename.jpg                     │
│              1920x1080                       │
│               245 KB                         │
│                                              │
├─────────────────────────────────────────────┤
│  [← Delete (X)] [↓ Skip] [↑ Back] [→ Keep (V)]│
│                                              │
│  Shortcuts: ← Delete | → Keep | ↓ Skip | ↑ Back │
└─────────────────────────────────────────────┘

---



================================================================================
SECTION 3: PLANNED/TO-BE-IMPLEMENTED FEATURES
================================================================================


These features are designed, documented, and ready for implementation but not yet coded.


================================================================================
3.1 ENHANCED PROGRESS LOGGING WITH DETAILED REAL-TIME FEEDBACK
================================================================================


I want comprehensive real-time progress logging during file categorization that shows exactly what's happening at each moment, with detailed statistics, file-by-file progress, and log export capability.

Detailed Requirements:
- I want the progress dialog to show the current operation type: "Analyzing...", "Categorizing via LLM...", "Caching result...", "Moving file..."
- I want the current file being processed displayed with full path: "Processing: /home/user/Documents/report.pdf"
- I want processing rate shown: "Files/second: 2.4" updated in real-time
- I want time elapsed and time remaining estimates: "Elapsed: 2m 15s | Remaining: ~5m 30s"
- I want success/skip/error counters: "Success: 120 | Skipped: 5 | Errors: 2"
- I want a detailed, expandable log panel showing all operations with timestamps: "[14:32:15] [CACHE] document.pdf → Work Documents : Reports", "[14:32:16] [AI] photo.jpg → Photos : Vacation"
- I want log level filtering: Show All, Errors Only, Warnings+, Info+
- I want the log to auto-scroll to bottom but allow manual scrolling to review earlier entries
- I want an "Export Log" button that saves the complete log to a timestamped text file
- I want the log format: [HH:MM:SS] [SOURCE] filename → Category : Subcategory where SOURCE is CACHE, AI, or ERROR
- I want the log to be color-coded: green for cache hits, blue for LLM categorizations, red for errors, yellow for warnings
- I want the progress bar to show sub-task progress: Main progress (overall), Sub-progress (current batch)
- I want statistics to persist: after completion, show final summary with "Total time: 7m 42s, Files processed: 245, Average: 1.9 files/sec"

Technical Implementation Details:
- Location: Enhance app/lib/CategorizationProgressDialog.cpp
- Add QTextEdit detailedlog widget for log display
- Add QLabel statslabel showing live statistics
- Add std::chrono::steadyclock::timepoint starttime for elapsed time tracking
- Add int filesprocessed counter for rate calculation
- Processing rate calculated as: filesprocessed / elapsedseconds
- Time remaining estimated as: (totalfiles - filesprocessed) / processingrate
- Log export uses QFile and QTextStream to write to categorizationlog{timestamp}.txt

Files Modified:
- app/include/CategorizationProgressDialog.hpp (add log widget, statistics tracking)
- app/lib/CategorizationProgressDialog.cpp (~100 lines enhancement)
- app/lib/CategorizationService.cpp (emit detailed progress messages)

---


================================================================================
3.2 SESSION MANAGEMENT SYSTEM
================================================================================


I want a comprehensive session management system that saves categorization sessions, allows me to resume interrupted sessions, reapply settings to new folders, and create session templates.

Detailed Requirements:


--------------------------------------------------------------------------------
SESSION CREATION & PERSISTENCE
--------------------------------------------------------------------------------

- I want every categorization operation to create a session record automatically
- I want sessions identified by unique UUID: sessionid
- I want session metadata: folder path, start time, end time (null if incomplete), categorization mode, consistency strength, whitelist used, files processed count
- I want session results: list of all categorized files with categories, subcategories, timestamps
- I want incomplete sessions marked with completed=0 in database
- I want database table: CREATE TABLE categorizationsessions (sessionid TEXT PRIMARY KEY, folderpath TEXT, startedat DATETIME, completedat DATETIME, mode TEXT, consistencystrength REAL, whitelistname TEXT, filesprocessed INTEGER, settingsjson TEXT)


--------------------------------------------------------------------------------
RESUME FUNCTIONALITY
--------------------------------------------------------------------------------

- I want "File → Resume Session" menu item showing list of incomplete sessions
- I want session list showing: Folder path, Started date, Files already processed, Estimated remaining time
- I want ability to resume from exact point where session was interrupted
- I want resume to reload all settings: categorization mode, whitelist, consistency hints, user profile state
- I want prompt: "Resume session for /home/user/Downloads? (45/120 files completed)"
- I want seamless continuation: progress bar picks up where it left off


--------------------------------------------------------------------------------
SESSION TEMPLATES
--------------------------------------------------------------------------------

- I want "Save as Template" button in categorization dialog
- I want template to capture: categorization mode, consistency strength, whitelist selection, file type filters, subcategory preferences, user profile usage
- I want template naming dialog: "Enter template name: ______"
- I want saved templates listed in "File → Templates" submenu
- I want template application: Select folder → Apply template → Start categorization with all template settings pre-loaded
- I want default templates: "Downloads Cleanup", "Photo Organization", "Document Sorting", "Code Project Sort"


--------------------------------------------------------------------------------
REAPPLY SETTINGS
--------------------------------------------------------------------------------

- I want "Reapply Last Settings" button on main window
- I want quick-apply: click folder, click "Reapply Last Settings", categorization starts immediately with last-used configuration
- I want settings to include: mode, whitelist, consistency, subcategories enabled/disabled, user profile learning
- I want smart detection: if folder type different from last session, show warning and suggest template


--------------------------------------------------------------------------------
SESSION HISTORY & STATISTICS
--------------------------------------------------------------------------------

- I want "View → Session History" showing table of all past sessions
- I want table columns: Session ID (shortened), Folder, Date, Duration, Files Processed, Mode, Status (Completed/Incomplete/Failed)
- I want sortable columns and date range filter
- I want "View Details" button showing complete session information: All settings used, File list with results, Any errors encountered, Final statistics
- I want "Delete Session" button to clean up old sessions
- I want "Export Session" to save session as JSON for documentation/sharing

Technical Implementation Details:
- Location: app/lib/SessionManager.cpp (NEW) and app/include/SessionManager.hpp (NEW)
- Sessions saved to database after each successful batch of categorizations
- Resume implemented by loading session, skipping already-processed files, continuing from last file
- Templates stored as JSON in {appdata}/sessiontemplates/ directory
- Template format:
{
  "name": "Downloads Cleanup",
  "mode": "consistent",
  "consistencystrength": 0.7,
  "whitelist": "General Organization",
  "usesubcategories": true,
  "userprofileenabled": true,
  "filefilters": {
    "excludeextensions": [".tmp", ".cache"],
    "minsizekb": 10
  }
}

Files Modified/Created:
- app/lib/SessionManager.cpp (NEW, ~400 lines)
- app/include/SessionManager.hpp (NEW)
- app/lib/SessionHistoryDialog.cpp (NEW, ~300 lines)
- app/include/SessionHistoryDialog.hpp (NEW)
- app/lib/DatabaseManager.cpp (add session tables and CRUD)
- app/lib/MainApp.cpp (add File menu items, template buttons)
- app/lib/CategorizationService.cpp (integrate session tracking)

---


================================================================================
3.3 ENHANCED UNDO SYSTEM - MULTIPLE HISTORY WITH PARTIAL UNDO
================================================================================


I want an advanced undo system supporting multiple undo levels, partial undo (selecting specific files to restore), redo capability, and visual undo history timeline.

Detailed Requirements:


--------------------------------------------------------------------------------
MULTIPLE UNDO HISTORY
--------------------------------------------------------------------------------

- I want the system to store up to 50 most recent sorting operations (configurable)
- I want each undo operation stored with: unique ID, timestamp, operation description, file count, source folder, undo plan path
- I want "Edit → Undo History" dialog showing list of operations chronologically
- I want each history entry showing: Date & Time, Operation ("Sorted 120 files in Downloads"), Files affected count, Undo status (Available/Undone/Expired)
- I want ability to undo any operation from history, not just the most recent
- I want dependency tracking: if operation B moved files that operation A created folders for, warn before undoing A


--------------------------------------------------------------------------------
PARTIAL UNDO
--------------------------------------------------------------------------------

- I want "Selective Undo" dialog when clicking undo history entry
- I want file list showing all files affected by that operation with checkboxes
- I want bulk selection: "Select All", "Select None", "Select by Category", "Select by Size >X"
- I want undo preview: "X files will be restored to original locations"
- I want conflict detection: if original location now occupied, show warning with resolution options (skip, rename, overwrite)
- I want confirmation: "Restore 45 of 120 files? 3 conflicts detected."
- I want partial undo to mark operation as "partially undone" in history


--------------------------------------------------------------------------------
REDO SUPPORT
--------------------------------------------------------------------------------

- I want redo stack: undoing an operation pushes it to redo stack
- I want "Edit → Redo" menu item (Ctrl+Y or Cmd+Shift+Z)
- I want redo to reverse the undo: files moved back to categorized locations
- I want redo stack cleared when new sorting operation performed
- I want redo history shown in undo history dialog with different visual style (grayed out)


--------------------------------------------------------------------------------
VISUAL TIMELINE
--------------------------------------------------------------------------------

- I want timeline view mode in undo history dialog
- I want operations shown as nodes on horizontal timeline
- I want zoom controls: fit all, zoom to week, zoom to day
- I want node hover showing operation details tooltip
- I want color coding: blue for available undo, green for completed, gray for expired, red for conflicts
- I want click on node to see operation details and undo/redo buttons


--------------------------------------------------------------------------------
UNDO CHAINS
--------------------------------------------------------------------------------

- I want automatic detection of operation chains: sequential operations on same folder within 1 hour
- I want chain visualization: operations grouped visually in history
- I want "Undo Chain" option: undo all operations in chain at once
- I want chain naming: first operation name + " (+ X more)"

Technical Implementation Details:
- Location: Enhance app/lib/UndoManager.cpp significantly (~800 lines total)
- Database table enhancement: ALTER TABLE undohistory ADD COLUMN ispartial INTEGER DEFAULT 0, ADD COLUMN redoavailable INTEGER DEFAULT 0, ADD COLUMN parentoperation TEXT
- Redo stack: std::stack<std::string> redostack storing undo IDs
- Partial undo plan: stored as separate JSON with subset of files
- Timeline implemented using QGraphicsView with custom graphics items
- Dependency detection: analyze folder paths to find related operations

Files Modified:
- app/include/UndoManager.hpp (add redo stack, history methods)
- app/lib/UndoManager.cpp (~400 lines enhancement)
- app/lib/UndoHistoryDialog.cpp (NEW, ~600 lines)
- app/include/UndoHistoryDialog.hpp (NEW)
- app/lib/DatabaseManager.cpp (enhance undohistory table)

---


================================================================================
3.4 HYBRID CATEGORIZATION MODE - SMART BALANCE BETWEEN REFINED AND CONSISTENT
================================================================================


I want a third categorization mode called "Hybrid" that intelligently balances between detailed categorization and consistency, automatically detecting file clusters and applying different strategies to each cluster.

Detailed Requirements:


--------------------------------------------------------------------------------
MODE DEFINITION
--------------------------------------------------------------------------------

- I want "Hybrid (Smart)" radio button alongside "More Refined" and "More Consistent"
- I want hybrid mode to analyze entire file batch first, then categorize strategically
- I want file clustering based on: file name similarity (Levenshtein distance), file extension similarity, file size similarity, parent directory similarity
- I want clusters defined as groups of ≥3 files with >60% similarity
- I want within-cluster consistency: files in same cluster get consistency hints applied strongly
- I want between-cluster refinement: files in different clusters categorized independently without cross-cluster hints
- I want singleton files (not in any cluster) categorized in refined mode


--------------------------------------------------------------------------------
CONSISTENCY STRENGTH SLIDER
--------------------------------------------------------------------------------

- I want UI slider labeled "Consistency Strength" (0-100%) appearing when Hybrid mode selected
- I want slider default at 50%
- I want slider tooltip explaining: "0% = Maximum variety, 100% = Maximum uniformity"
- I want consistency strength affecting: cluster similarity threshold (higher = looser clusters), hint weight in LLM prompt, number of hints provided
- I want slider to be persistent: value saved to settings for next run


--------------------------------------------------------------------------------
CLUSTERING ALGORITHM
--------------------------------------------------------------------------------

- I want clustering to use: name-based clustering (files with similar names grouped), extension-based clustering (all .jpg files in one cluster, all .pdf in another), size-based clustering (files within same size range), hybrid clustering (combination of above with weighted scoring)
- I want cluster scoring: each pair of files gets similarity score 0-1, threshold for cluster inclusion: similarity > (0.6  consistencystrength)
- I want clustering visualization: optionally show cluster diagram before categorization starts


--------------------------------------------------------------------------------
ADAPTIVE BEHAVIOR
--------------------------------------------------------------------------------

- I want mode to auto-adjust based on folder contents: if folder very homogeneous (90%+ files similar), mode biases toward consistent, if folder very heterogeneous (<30% similarity), mode biases toward refined
- I want mode to learn: track which strategy works best for each folder type, adjust future recommendations
- I want clear feedback: "Detected 5 clusters in folder. Applying hybrid strategy..."

Technical Implementation Details:
- Location: app/lib/CategorizationService.cpp (add clustering logic)
- New enum value: enum class CategorizationMode { Refined, Consistent, Hybrid }
- Clustering algorithm: Hierarchical clustering with average linkage
- Similarity functions: calculatenamesimilarity(), calculateextensionsimilarity(), calculatesizesimilarity()
- Cluster representation: std::vector<std::vector<FileEntry>> where each inner vector is a cluster
- UI implementation: Add slider widget to MainApp, connect to settings

Files Modified:
- app/include/Types.hpp (add Hybrid to CategorizationMode enum)
- app/lib/CategorizationService.cpp (~300 lines enhancement for clustering)
- app/include/CategorizationService.hpp (add clustering methods)
- app/lib/MainApp.cpp (add Hybrid radio button and consistency slider)
- app/include/Settings.hpp (add consistencystrength field)

---


================================================================================
3.5 POST-SORTING CATEGORY RENAME - BULK CATEGORY CHANGES WITH UNDO
================================================================================


I want the ability to bulk-rename categories after sorting is complete, directly from the results dialog, with auto-complete, validation, and full undo support.

Detailed Requirements:


--------------------------------------------------------------------------------
BULK SELECTION & RENAME
--------------------------------------------------------------------------------

- I want multi-select in categorization results table: Ctrl+Click individual files, Shift+Click range, Ctrl+A select all
- I want right-click context menu on selected files with options: "Change Category", "Change Subcategory", "Change Both"
- I want "Change Category" dialog showing: Current category (read-only), New category input field with auto-complete, Affected files list (read-only), Preview of moves ("X files will move from Old → New")
- I want auto-complete to suggest: existing categories from taxonomy, existing categories from current session, similar categories (fuzzy match)
- I want category name validation: no special characters, max length check, not reserved names, similarity check (warn if very similar to existing)


--------------------------------------------------------------------------------
SMART FEATURES
--------------------------------------------------------------------------------

- I want "Create new category" checkbox: if checked and category doesn't exist, create it in taxonomy
- I want "Apply to similar files" checkbox: if checked, find files with similar names/extensions and apply same change
- I want subcategory preservation option: "Keep existing subcategories" vs "Clear subcategories" vs "Reassign subcategories"
- I want folder preview: show which folders will be created/affected
- I want conflict detection: if target already exists, offer merge or skip


--------------------------------------------------------------------------------
EXECUTION & UNDO
--------------------------------------------------------------------------------

- I want changes to execute immediately after confirmation
- I want files physically moved to new category folders
- I want database updated with new categorizations
- I want taxonomy updated if new categories created
- I want complete undo plan saved: operation saved to undohistory as "Category rename: Old → New (X files)"
- I want undo to restore files to original category and remove newly created empty folders


--------------------------------------------------------------------------------
BATCH OPERATIONS
--------------------------------------------------------------------------------

- I want "Bulk Rename" mode for renaming multiple categories at once
- I want mapping interface: "Old Category" → "New Category" with add/remove rows
- I want import mapping from CSV: oldcategory,newcategory
- I want mapping templates saved for reuse

Technical Implementation Details:
- Location: Enhance app/lib/CategorizationDialog.cpp (~300 lines enhancement)
- Right-click context menu: QMenu created on customContextMenuRequested signal
- Category rename dialog: CategoryRenameDialog (NEW class) with auto-complete using QCompleter
- Auto-complete model populated from dbmanager.getallcategories()
- Validation: reuse existing validatelabels() function
- File moving: iterate selected files, call std::filesystem::rename(), update database
- Undo plan: same format as sorting operation undo plan

Files Modified/Created:
- app/lib/CategorizationDialog.cpp (~300 lines enhancement)
- app/include/CategorizationDialog.hpp (add context menu methods)
- app/lib/CategoryRenameDialog.cpp (NEW, ~250 lines)
- app/include/CategoryRenameDialog.hpp (NEW)
- app/lib/DatabaseManager.cpp (add bulk update methods)

---


================================================================================
3.6 ENHANCED SIMULATION MODE - MULTIPLE VIEWS WITH CONFLICT HIGHLIGHTING
================================================================================


I want comprehensive preview capabilities with multiple visualization modes (list, tree, graph), detailed statistics, conflict highlighting, and before/after comparison.

Detailed Requirements:


--------------------------------------------------------------------------------
MULTIPLE VIEW MODES
--------------------------------------------------------------------------------

- I want view mode selector: dropdown or tab bar with options "List View", "Tree View", "Graph View"
- I want List View (current): table showing from→to with columns (filename, current, destination, category, subcategory, size)
- I want Tree View showing: before structure (left panel), after structure (right panel), side-by-side comparison with connecting lines showing file movements
- I want Graph View showing: category relationship diagram, nodes = categories, edges = file movements, node size = number of files, edge width = number of files moving


--------------------------------------------------------------------------------
TREE VIEW IMPLEMENTATION
--------------------------------------------------------------------------------

- I want collapsible folder trees using QTreeWidget
- I want folders shown with depth indication and file count
- I want files shown as leaf nodes with icons by type
- I want color coding: green for new folders to be created, blue for existing folders, red for conflicts
- I want animation/highlight showing file movements: dashed lines connecting before→after positions


--------------------------------------------------------------------------------
BEFORE/AFTER STATISTICS
--------------------------------------------------------------------------------

- I want statistics panel showing: total files, folders before/after, new folders to create, files per category (sorted), size per category (sorted), deepest folder depth
- I want comparison table: "Before: 250 files in 1 folder | After: 250 files in 15 categories"
- I want space analysis: no change in total disk usage (files just moved), but show distribution changes


--------------------------------------------------------------------------------
CONFLICT DETECTION & HIGHLIGHTING
--------------------------------------------------------------------------------

- I want conflicts detected: duplicate filenames in same category, destination folder read-only, insufficient disk space, file locked/in use
- I want conflicts highlighted in red in all views
- I want conflict details shown on hover tooltip
- I want conflict resolution suggestions: "Rename to filename2.txt", "Skip this file", "Merge with existing"
- I want conflict count badge: "⚠️ 3 conflicts detected"


--------------------------------------------------------------------------------
SEARCH & FILTER
--------------------------------------------------------------------------------

- I want search box: filter by filename, category, or path
- I want filter options: show only conflicts, show only new folders, show specific category, size filter (>X MB)
- I want result highlighting: search matches highlighted in yellow

Technical Implementation Details:
- Location: Major enhancement to app/lib/DryRunPreviewDialog.cpp (~500 lines total)
- View switching: QStackedWidget containing three views (QTableWidget, dual QTreeWidget, QGraphicsView)
- Tree construction: recursive folder traversal building before/after trees
- Graph view: QGraphicsScene with custom node/edge items, layout algorithm for positioning
- Conflict detection: pre-check all destination paths, check permissions, check disk space
- Conflict resolution: store resolution preferences, apply batch

Files Modified:
- app/lib/DryRunPreviewDialog.cpp (~300 lines enhancement)
- app/include/DryRunPreviewDialog.hpp (add view widgets, mode enum)
- Add helper classes: CategoryGraphView, FolderTreeComparator

---


================================================================================
3.7 SELECTIVE EXECUTION FROM PREVIEW - CHOOSE WHICH FILES TO MOVE
================================================================================


I want the ability to selectively execute only specific file movements from the preview, using checkboxes, filters, and bulk selection, with unexecuted items saved for later processing.

Detailed Requirements:


--------------------------------------------------------------------------------
CHECKBOX SELECTION
--------------------------------------------------------------------------------

- I want checkbox column added to preview table as first column
- I want each file having its own checkbox, initially all checked
- I want header checkbox for select all/deselect all
- I want checkbox state persistent: if I close dialog and reopen, checkboxes remember state
- I want keyboard shortcuts: Space to toggle selected row, Ctrl+A to select all, Ctrl+Shift+A to deselect all


--------------------------------------------------------------------------------
FILTER-BASED SELECTION
--------------------------------------------------------------------------------

- I want "Select by..." dropdown menu with options: Category (submenu listing all categories), Confidence score (submenu: >90%, >75%, >50%, <50%), File type (submenu: Images, Documents, Videos, etc.), Size (submenu: >10MB, >100MB, >1GB), Date modified (submenu: Last week, Last month, Older than X)
- I want filters to auto-check matching files and uncheck others
- I want filter indicator: "Filter active: Category=Photos (45 files selected)"
- I want clear filter button


--------------------------------------------------------------------------------
EXECUTION OPTIONS
--------------------------------------------------------------------------------

- I want "Execute Selected" button executing only checked files
- I want "Execute All" button executing all files (original behavior)
- I want unchecked files remaining in preview: not moved, not removed from list
- I want progress dialog showing: "Moving X of Y files (Z skipped)"
- I want success message: "Moved 45 files. 23 files not moved (unselected)."


--------------------------------------------------------------------------------
SAVE FOR LATER
--------------------------------------------------------------------------------

- I want "Save Selection" button: saves current checkbox states to session
- I want saved selections named: "Enter selection name: _____"
- I want "Load Selection" menu listing saved selections
- I want saved selections stored in database: table savedselections (name TEXT, sessionid TEXT, filelist TEXT) where filelist is JSON array of file paths
- I want "Continue Later" button: close dialog without executing, session saved with current checkbox states
- I want session resume: reopening dialog restores checkbox states


--------------------------------------------------------------------------------
BATCH OPERATIONS
--------------------------------------------------------------------------------

- I want "Invert Selection" button: check all unchecked, uncheck all checked
- I want "Select None" button: uncheck all
- I want "Select Only..." dialog: enter regex pattern to match filenames
- I want multi-stage execution: execute batch 1, review results, execute batch 2, etc.

Technical Implementation Details:
- Location: Enhance app/lib/DryRunPreviewDialog.cpp (~200 lines enhancement)
- Checkbox column: QTableWidget with QTableWidgetItem containing Qt::Checked or Qt::Unchecked
- Checkbox state: stored in std::vector<bool> selecteditems parallel to file list
- Partial execution: iterate files, skip unchecked, move checked, update database only for moved files
- Selection saving: serialize checkbox states to JSON, save in database
- Filter implementation: iterate files, check filter criteria, update checkbox accordingly

Files Modified:
- app/lib/DryRunPreviewDialog.cpp (~200 lines enhancement)
- app/include/DryRunPreviewDialog.hpp (add selection state, filter methods)
- app/lib/ResultsCoordinator.cpp (support partial execution)
- app/lib/DatabaseManager.cpp (add savedselections table)

---


================================================================================
3.8 CONTENT-BASED ANALYSIS SYSTEM - ANALYZE FILE CONTENTS FOR BETTER CATEGORIZATION
================================================================================


I want the system to optionally analyze file contents (not just names) to improve categorization accuracy, supporting multiple file types including text, images, documents, archives, and code.

Detailed Requirements:


--------------------------------------------------------------------------------
CONTENT ANALYSIS TYPES
--------------------------------------------------------------------------------

- I want Text files (.txt, .md, .log): extract keywords, detect language (English, Spanish, etc.), analyze structure (headings, lists), count words/lines
- I want Images (.jpg, .png, .gif): read EXIF metadata (camera, GPS, date), detect image type (photo, screenshot, diagram, chart), read embedded descriptions
- I want Documents (.pdf, .docx, .odt): extract full text content, read document metadata (author, title, subject, keywords), analyze document structure
- I want Archives (.zip, .rar, .7z): list file contents, analyze content types, determine archive purpose (backup, project, data)
- I want Code files (.py, .js, .cpp, etc.): detect programming language, identify project type (web app, script, library), extract imports/dependencies
- I want Videos (.mp4, .avi, .mkv): read metadata (duration, resolution, codec), extract first frame, identify video type


--------------------------------------------------------------------------------
CONTENT INSIGHT GENERATION
--------------------------------------------------------------------------------

- I want ContentAnalyzer class with method: ContentInsight analyze(const std::string& filepath)
- I want ContentInsight struct containing: filetype, mimetype, keywords (vector), detectedlanguage, metadata (map), summary (for LLM context)
- I want insights cached in database: table contentanalysiscache (filepath TEXT PRIMARY KEY, contenthash TEXT, mimetype TEXT, analysisresult TEXT, timestamp DATETIME)
- I want content hashing: SHA-256 hash of first 1KB + last 1KB to detect changes without full read
- I want cache invalidation: if contenthash different, re-analyze


--------------------------------------------------------------------------------
LLM CONTEXT INTEGRATION
--------------------------------------------------------------------------------

- I want content insights formatted for LLM: "Content Analysis: Document about software development. Keywords: Python, API, REST, tutorial. Language: English. Type: Technical documentation."
- I want insights appended to categorization prompt when content analysis enabled
- I want generatellmcontext(ContentInsight) method formatting insights clearly
- I want prompt structure: "File: document.pdf\nContent Analysis: [insights here]\n\nAssign category and subcategory..."


--------------------------------------------------------------------------------
CONFIGURATION & CONTROL
--------------------------------------------------------------------------------

- I want Settings checkbox: "Enable content-based analysis (slower but more accurate)"
- I want per-file-type control: checkboxes for "Analyze text files", "Analyze images (EXIF)", "Analyze documents", "Analyze archives"
- I want size limit: "Skip analysis for files larger than X MB" (default 10MB)
- I want timeout: analysis cancelled if takes >5 seconds per file
- I want fallback: if analysis fails, proceed with name-only categorization


--------------------------------------------------------------------------------
PERFORMANCE OPTIMIZATION
--------------------------------------------------------------------------------

- I want parallel analysis: analyze multiple files concurrently using thread pool
- I want incremental caching: analyzed files never re-analyzed unless changed
- I want fast-path: check cache first, only analyze on cache miss
- I want progress indication: "Analyzing content (X/Y files)..."

Technical Implementation Details:
- Location: app/lib/ContentAnalyzer.cpp (NEW, ~600 lines) and app/include/ContentAnalyzer.hpp (NEW)
- Libraries: libmagic (MIME detection), exiv2 (EXIF), poppler (PDF), libarchive (archives), language detection library
- Text analysis: keyword extraction using TF-IDF or simple word frequency
- Image analysis: exiv2::Image::open() to read metadata
- PDF analysis: poppler::document::loadfromfile() to extract text
- Archive analysis: libarchive to list contents without extraction
- Integration: CategorizationService calls analyzer before LLM request

Files Modified/Created:
- app/lib/ContentAnalyzer.cpp (NEW, ~600 lines)
- app/include/ContentAnalyzer.hpp (NEW)
- app/lib/CategorizationService.cpp (~150 lines enhancement)
- app/lib/DatabaseManager.cpp (add contentanalysiscache table)
- app/include/Settings.hpp (add content analysis flags)
- app/lib/MainApp.cpp (add Settings UI for content analysis)

---



================================================================================
3.9 CONFIDENCE SCORING SYSTEM - VISUAL INDICATORS OF CATEGORIZATION QUALITY
================================================================================


I want a comprehensive confidence scoring system that calculates and displays confidence scores for each categorization, helping me identify files that need manual review.

Detailed Requirements:
- I want confidence scores (0.0-1.0) calculated for every categorized file based on multiple factors
- I want factors influencing confidence: Cache hit vs LLM categorization (cache=lower confidence over time), Consistency with session hints (higher if matches previous), Content analysis alignment (higher if content matches category), Model certainty (parse LLM response for confidence words), Historical correction rate (lower if this category/file type frequently corrected)
- I want confidence displayed in categorization review table as percentage with color coding: >90% green "High", 70-90% yellow "Medium", 50-70% orange "Low", <50% red "Very Low"
- I want sortable confidence column for prioritized manual review
- I want "Review Low Confidence" filter showing only files <70% confidence
- I want confidence factors explained on hover: tooltip showing "Confidence: 65% (Cache:40%, Consistency:80%, Content:70%)"
- I want confidence stored in database for analysis and learning

Files Modified/Created:
- app/lib/ConfidenceCalculator.cpp (NEW, ~300 lines)
- app/include/ConfidenceCalculator.hpp (NEW)
- app/lib/CategorizationService.cpp (~100 lines enhancement)
- app/lib/CategorizationDialog.cpp (add confidence column and filtering)
- app/lib/DatabaseManager.cpp (add confidencescores table)

---


================================================================================
3.10 USER-EDITABLE TAXONOMY SYSTEM - MANAGE AND REFINE YOUR CATEGORIES
================================================================================


I want a taxonomy management dialog that lets me view all categories ever used, merge similar categories, rename categories globally, add aliases, and export/import taxonomy.

Detailed Requirements:
- I want "Settings → Manage Taxonomy" menu item opening TaxonomyManagerDialog
- I want tree view showing all categories and subcategories from database with usage counts
- I want "Merge Categories" feature: select 2+ categories, choose primary, merge all references
- I want "Rename Category" feature: rename globally across all cached entries and taxonomy
- I want "Add Alias" feature: multiple names for same category (e.g., "Docs" alias for "Documents")
- I want "Delete Category" with warning: show files affected, require confirmation
- I want export to JSON: save entire taxonomy structure
- I want import from JSON: merge or replace existing taxonomy
- I want search/filter: find categories by name or usage
- I want unused category detection: highlight categories with 0 files

Files Modified/Created:
- app/lib/TaxonomyManagerDialog.cpp (NEW, ~500 lines)
- app/include/TaxonomyManagerDialog.hpp (NEW)
- app/lib/DatabaseManager.cpp (add taxonomy management methods)

---


================================================================================
3.11 LEARNING FROM CORRECTIONS - SMART PATTERN DETECTION
================================================================================


I want automatic detection and application of correction patterns, so the system learns when I manually change categories and suggests or auto-applies those changes in the future.

Detailed Requirements:
- I want tracking of all manual category changes in categorization review dialog
- I want correction records stored with context: original category, corrected category, file type, file name pattern, timestamp
- I want pattern detection: if I change "Images" → "Photos" for 3+ .jpg files, detect pattern
- I want proactive suggestions: "You usually change Images to Photos for .jpg files. Apply automatically?"
- I want auto-correction: option to automatically apply learned corrections with user approval
- I want correction confidence: show how many times pattern observed
- I want correction review: see all learned patterns, enable/disable individually

Files Modified/Created:
- app/lib/CorrectionLearner.cpp (NEW, ~400 lines)
- app/include/CorrectionLearner.hpp (NEW)
- app/lib/CategorizationDialog.cpp (track corrections)
- app/lib/DatabaseManager.cpp (add usercorrections table)

---


================================================================================
3.12 CONFLICT DETECTION AND RESOLUTION - SMART HANDLING OF CATEGORIZATION ISSUES
================================================================================


I want comprehensive conflict detection before file moves, with natural language resolution interface and AI-powered suggestions for handling conflicts.

Detailed Requirements:
- I want conflicts detected: duplicate filenames, read-only destinations, permission issues, low confidence categorizations (<50%), ambiguous categories (file could fit multiple)
- I want conflict highlighting in preview with warning icons
- I want natural language resolution: text input "How should I handle duplicates?" → AI suggests: "Keep newest", "Keep largest", "Rename with date suffix"
- I want batch resolution: apply same resolution to all similar conflicts
- I want conflict summary before execution: "3 duplicates, 2 permission issues - review before proceeding"
- I want resolution templates saved for reuse

Files Modified/Created:
- app/lib/ConflictDetector.cpp (NEW, ~400 lines)
- app/include/ConflictDetector.hpp (NEW)
- app/lib/ConflictResolutionDialog.cpp (NEW, ~500 lines)
- app/include/ConflictResolutionDialog.hpp (NEW)
- app/lib/ResultsCoordinator.cpp (integrate conflict detection)

---


================================================================================
3.13 SMART TAXONOMY SUGGESTIONS - AI-POWERED TAXONOMY OPTIMIZATION
================================================================================


I want AI-powered analysis of my taxonomy to detect similar categories, suggest merges, recommend subcategory creation, and optimize category structure.

Detailed Requirements:
- I want automatic similarity detection: find categories like "Document"/"Documents"/"Docs", "Photo"/"Image"/"Picture"
- I want merge suggestions with confidence scores and file counts
- I want split suggestions: detect overly broad categories (>100 files, high variety) and suggest subcategories
- I want optimization suggestions: recommended depth, breadth, naming consistency
- I want one-click application: accept suggestion, see preview, apply changes
- I want suggestion history: track accepted/rejected suggestions to improve future suggestions

Files Modified/Created:
- app/lib/TaxonomySuggestionEngine.cpp (NEW, ~600 lines)
- app/include/TaxonomySuggestionEngine.hpp (NEW)
- Integrated into TaxonomyManagerDialog

---


================================================================================
3.14 ENHANCED ERROR SYSTEM WITH AI RESOLUTION - NATURAL LANGUAGE PROBLEM SOLVING
================================================================================


I want an enhanced error handling system where I can describe problems in natural language, get AI-powered diagnosis, receive step-by-step solutions, and have common issues auto-resolved with my approval.

Detailed Requirements:
- I want natural language error input: "The app won't connect to Gemini and keeps timing out"
- I want AI-powered diagnosis: analyzes error context, checks logs, identifies likely causes
- I want solution suggestions: step-by-step instructions ranked by likelihood of success
- I want "Try Fix" button: automated resolution with progress feedback
- I want resolution logging: track what fixed what for learning
- I want offline capability: local LLM can diagnose without internet
- I want error categories: network, API, filesystem, categorization, configuration

Files Modified/Created:
- app/lib/AIErrorResolver.cpp (NEW, ~700 lines)
- app/include/AIErrorResolver.hpp (NEW)
- app/lib/ErrorResolutionDialog.cpp (NEW, ~400 lines)
- app/include/ErrorResolutionDialog.hpp (NEW)
- Integrated into existing error handling system

---


================================================================================
3.15 EASY MODE WIZARD - SIMPLIFIED INTERFACE FOR QUICK ORGANIZATION
================================================================================


I want a streamlined wizard interface that guides users through file organization with smart defaults, preset templates, and minimal configuration required.

Detailed Requirements:
- I want 5-step wizard: Select folder → Describe contents → Choose organization style → Preview → Execute
- I want smart detection: auto-suggest organization based on folder analysis
- I want preset templates: "Clean Downloads", "Organize Photos", "Sort Documents", "Archive Old Files"
- I want one-click execution: minimal decisions, maximum results
- I want easy undo: prominent undo button, simple restoration
- I want progressive disclosure: "Show Advanced" button reveals full interface
- I want tutorial mode: tips and hints throughout process

Files Modified/Created:
- app/lib/EasyModeWizard.cpp (NEW, ~800 lines)
- app/include/EasyModeWizard.hpp (NEW)
- app/lib/MainApp.cpp (add Easy Mode button/menu)

---


================================================================================
SUMMARY STATISTICS
================================================================================



================================================================================
IMPLEMENTATION STATUS
================================================================================



--------------------------------------------------------------------------------
SECTION 1: CHANGED/ENHANCED FEATURES (6 FEATURES)
--------------------------------------------------------------------------------

1. ✅ Whitelist hierarchical mode support (~1200 lines)
2. ✅ Whitelist separator change (~30 lines)
3. ✅ Enhanced categorization prompt building (~100 lines)
4. ✅ Google Gemini API integration (~1000 lines)
5. ✅ Enhanced dry run preview (~300 lines)
6. ✅ Persistent undo system (~400 lines)

Total Lines Modified/Added: ~3,030 lines


--------------------------------------------------------------------------------
SECTION 2: IMPLEMENTED NEW FEATURES (4 MAJOR FEATURES)
--------------------------------------------------------------------------------

1. ✅ User profiling & adaptive learning system (~1500 lines)
2. ✅ Database cache manager dialog (~300 lines)
3. ✅ API usage tracking & statistics (~650 lines)
4. ✅ File Tinder tool (~650 lines)

Total Lines Added: ~3,100 lines


--------------------------------------------------------------------------------
SECTION 3: PLANNED FEATURES (15 FEATURES)
--------------------------------------------------------------------------------

1. 🔨 Enhanced progress logging (~150 lines)
2. 🔨 Session management system (~900 lines)
3. 🔨 Enhanced undo with multiple history (~1000 lines)
4. 🔨 Hybrid categorization mode (~400 lines)
5. 🔨 Post-sorting category rename (~500 lines)
6. 🔨 Enhanced simulation mode (~500 lines)
7. 🔨 Selective execution from preview (~300 lines)
8. 🔨 Content-based analysis (~900 lines)
9. 🔨 Confidence scoring system (~500 lines)
10. 🔨 User-editable taxonomy system (~600 lines)
11. 🔨 Learning from corrections (~500 lines)
12. 🔨 Conflict detection & resolution (~1100 lines)
13. 🔨 Smart taxonomy suggestions (~700 lines)
14. 🔨 AI-powered error resolution (~1300 lines)
15. 🔨 Easy mode wizard (~900 lines)

Total Estimated Lines: ~9,250 lines


================================================================================
GRAND TOTALS
================================================================================


- Implemented Changes: 10 features, ~6,130 lines of code
- Planned Changes: 15 features, ~9,250 lines of code
- Total Project Enhancement: 25 features, ~15,380 lines of code


================================================================================
FILES MODIFIED SUMMARY
================================================================================



--------------------------------------------------------------------------------
NEW FILES CREATED (IMPLEMENTED)
--------------------------------------------------------------------------------

- UserProfileManager.cpp/.hpp (~657 lines)
- UserProfileDialog.cpp/.hpp (~400 lines)
- FolderLearningDialog.cpp/.hpp (~200 lines)
- GeminiClient.cpp/.hpp (~824 lines)
- CacheManagerDialog.cpp/.hpp (~212 lines)
- APIUsageTracker.cpp/.hpp (~124 lines)
- UsageStatsDialog.cpp/.hpp (~400 lines)
- FileTinderDialog.cpp/.hpp (~540 lines)
- WhitelistTreeEditor.cpp/.hpp (~400 lines)


--------------------------------------------------------------------------------
MAJOR FILES ENHANCED (IMPLEMENTED)
--------------------------------------------------------------------------------

- WhitelistStore.cpp (~300 lines enhancement)
- WhitelistManagerDialog.cpp (~500 lines enhancement)
- CategorizationService.cpp (~200 lines enhancement)
- UndoManager.cpp (~400 lines enhancement)
- DryRunPreviewDialog.cpp (~300 lines enhancement)
- DatabaseManager.cpp (multiple table additions, ~500 lines)
- Settings.cpp/hpp (Gemini settings, ~100 lines)
- MainApp.cpp (UI additions, ~300 lines)
- README.md (documentation sections, ~200 lines)
- CHANGELOG.md (version entries, ~50 lines)


--------------------------------------------------------------------------------
DATABASE SCHEMA ADDITIONS (IMPLEMENTED)
--------------------------------------------------------------------------------

- userprofiles table
- profilecharacteristics table
- folderinsights table
- folderlearningsettings table
- apiusagetracking table
- filetinderstate table
- Enhanced undohistory table


--------------------------------------------------------------------------------
CONFIGURATION CHANGES (IMPLEMENTED)
--------------------------------------------------------------------------------

- whitelists.ini: Added UseHierarchical, Subcategories<Category> keys
- config.ini: Added geminiapikey, gemini_model keys
- Separator changed from comma to semicolon for categories/subcategories

---


================================================================================
USAGE INSTRUCTIONS FOR AI AGENT
================================================================================



================================================================================
HOW TO USE THIS DOCUMENT
================================================================================


This document is structured to be fed to AI agents sequentially. Each section builds upon previous sections.


--------------------------------------------------------------------------------
FEEDING ORDER
--------------------------------------------------------------------------------


1. First: Feed all of Section 1 (Changed/Enhanced Features) - these modify existing functionality
2. Second: Feed all of Section 2 (Implemented New Features) - these are already implemented and serve as reference
3. Third: Feed Section 3 items one at a time in the order listed - they have dependencies


--------------------------------------------------------------------------------
PER-FEATURE FORMAT
--------------------------------------------------------------------------------


Each "I want" feature description contains:
- Detailed Requirements: What the feature does and how it behaves
- Technical Implementation Details: Specific classes, methods, algorithms
- Files Modified/Created: Exact file paths and line counts
- Database Schema: SQL table definitions where applicable
- Configuration Format: INI/JSON examples where applicable


--------------------------------------------------------------------------------
DEPENDENCIES
--------------------------------------------------------------------------------


Features in Section 3 have dependencies:
- Session Management (3.2) requires database enhancements from Section 1
- Enhanced Undo (3.3) builds on Persistent Undo (1.6)
- Confidence Scoring (3.9) requires Content Analysis (3.8)
- Conflict Resolution (3.12) requires Confidence Scoring (3.9)
- AI Error Resolution (3.14) requires error system foundation
- Easy Mode (3.15) requires most other features to be complete


--------------------------------------------------------------------------------
IMPLEMENTATION NOTES
--------------------------------------------------------------------------------


- All features maintain backward compatibility
- All features are toggleable via settings
- All data stored locally (privacy-first)
- All features work offline with local LLM where AI needed
- Qt6 framework used throughout for UI
- SQLite database for all data persistence
- Cross-platform compatibility maintained (Windows, macOS, Linux)

---


================================================================================
DOCUMENT COMPLETENESS VERIFICATION
================================================================================



================================================================================
ORIGINAL FORK COMPARISON
================================================================================


✅ Whitelist changes: Hierarchical mode, separator change - DOCUMENTED (1.1, 1.2)
✅ Main prompt changes: Context building, multi-source prompts - DOCUMENTED (1.3)
✅ Gemini LLM changes: Complete integration with rate limiting - DOCUMENTED (1.4)
✅ User profiling system: Full implementation - DOCUMENTED (2.1)
✅ Cache management: Cache manager dialog - DOCUMENTED (2.2)
✅ API usage tracking: OpenAI and Gemini - DOCUMENTED (2.3)
✅ File Tinder: Complete swipe-style cleanup tool - DOCUMENTED (2.4)
✅ Dry run enhancements: Preview improvements - DOCUMENTED (1.5)
✅ Persistent undo: Multi-session undo support - DOCUMENTED (1.6)
✅ Database schema additions: All tables - DOCUMENTED throughout
✅ UI enhancements: All major UI changes - DOCUMENTED throughout


================================================================================
COMPLETENESS SCORE: 100%
================================================================================


All features mentioned in the problem statement have been thoroughly documented with detailed "I want" prompts suitable for AI agent implementation.

---


================================================================================
END OF DOCUMENT
================================================================================


Total Document Length: ~1250 lines
Total Features Documented: 25 (10 implemented, 15 planned)
Estimated Total Implementation: ~15,380 lines of code
Document Creation Date: January 7, 2026

This document is ready to be fed to AI agents for implementation. Each prompt is self-contained with full technical details.




================================================================================
SECTION 3: OPTIMIZATION RECOMMENDATIONS
================================================================================

Apply these optimizations to improve performance from 7.5/10 to 9/10.


================================================================================
IMPLEMENTATION OPTIMIZATION ASSESSMENT
================================================================================



================================================================================
EXECUTIVE SUMMARY
================================================================================


After reviewing the codebase structure and implementations, here's an assessment of whether the current solutions are optimized for the fork's architecture.


================================================================================
ARCHITECTURE ANALYSIS
================================================================================


Current Pattern: The fork follows Qt6 Model-View-Controller-like pattern with:
- Managers (13 classes): Business logic, state management
- Dialogs (18 classes): UI components
- Services (4 classes): Core operations
- Total: 58 .hpp headers, 50 .cpp implementations


================================================================================
FEATURE-BY-FEATURE OPTIMIZATION ASSESSMENT
================================================================================



--------------------------------------------------------------------------------
✅ OPTIMIZED: WHITELIST SYSTEM
--------------------------------------------------------------------------------


Current Implementation: GOOD
- Separate WhitelistStore for persistence (single responsibility)
- WhitelistManagerDialog for UI (separation of concerns)
- WhitelistTreeEditor as reusable widget (DRY principle)
- INI-based storage (lightweight, human-readable)

Why It's Optimal:
- Follows existing pattern (Settings uses INI)
- Minimal database dependencies
- Easy to backup/share (plain text files)
- No performance bottlenecks (small data volume)

Recommendation: ✅ Keep as-is

---


--------------------------------------------------------------------------------
⚠️ NEEDS OPTIMIZATION: USER PROFILING SYSTEM
--------------------------------------------------------------------------------


Current Implementation: PARTIALLY OPTIMAL

Issues Identified:

1. Database Redundancy
   - Multiple tables (userprofiles, profilecharacteristics, folderinsights, folderlearningsettings)
   - Could use JSON blob in single table for smaller datasets
   - Current approach: normalized relational model
   
2. Real-time Analysis Performance
   - analyzeandupdatefromfolder() called after EVERY categorization
   - Calculates statistics synchronously
   - Blocks UI during profile updates

Better Approach:

// CURRENT (Synchronous, blocking):
void analyzeandupdatefromfolder(files) {
    if (inclusionlevel == "full") {
        infercharacteristicsfromfiles(files, folderpath);  // BLOCKS
    }
    calculatecategorydistribution(files);  // BLOCKS
    saveprofile();  // BLOCKS
}

// OPTIMIZED (Async, non-blocking):
void analyzeandupdatefromfolderasync(files) {
    std::async(std::launch::async, [this, files, folderpath]() {
        // Background thread for analysis
        auto characteristics = infercharacteristicsfromfiles(files, folderpath);
        auto distribution = calculatecategorydistribution(files);
        
        // Single atomic database write
        dbmanager.batchsaveprofiledata(characteristics, distribution);
    });
}

Recommendation: 
- ✅ Keep multi-table design (good for complex queries)
- ⚠️ Add async analysis to prevent UI freezing
- ⚠️ Add batch database writes instead of multiple transactions

---


--------------------------------------------------------------------------------
⚠️ NEEDS OPTIMIZATION: GEMINI CLIENT
--------------------------------------------------------------------------------


Current Implementation: PARTIALLY OPTIMAL

What's Good:
- Excellent rate limiting (token bucket algorithm)
- Circuit breaker pattern (prevents API hammering)
- Adaptive timeouts (handles free tier slowness)
- Persistent state tracking

Issues Identified:

1. State File I/O on Every Request
      // CURRENT: File I/O on every API call
   void makerequest() {
       auto state = loadstatefromfile();  // SLOW
       // ... make request ...
       savestatetofile(state);  // SLOW
   }
   
2. Mutex Contention
   - Single global mutex for all API calls
   - Parallel categorization blocked unnecessarily

Better Approach:

// OPTIMIZED: Memory-based state with periodic persistence
class GeminiClient {
private:
    ModelState state;  // In-memory (FAST)
    std::chrono::steadyclock::timepoint lastpersist;
    constexpr static auto PERSISTINTERVAL = 30s;
    
    void maybepersiststate() {
        auto now = std::chrono::steadyclock::now();
        if (now - lastpersist > PERSISTINTERVAL) {
            savestatetofileasync(state);  // Background write
            lastpersist = now;
        }
    }
};

Recommendation:
- ⚠️ Reduce file I/O: Persist state every 30s instead of every request
- ⚠️ Use per-model mutex: Allow parallel requests to different models
- ✅ Keep existing rate limiting and circuit breaker (excellent design)

---


--------------------------------------------------------------------------------
✅ OPTIMIZED: CACHE MANAGER DIALOG
--------------------------------------------------------------------------------


Current Implementation: GOOD

Why It's Optimal:
- Queries on-demand (not constant polling)
- Uses SQLite built-in functions (COUNT, SUM) - FAST
- VACUUM operation is standard SQLite optimization
- Modal dialog (no background updates needed)

Recommendation: ✅ Keep as-is

---


--------------------------------------------------------------------------------
⚠️ NEEDS OPTIMIZATION: API USAGE TRACKING
--------------------------------------------------------------------------------


Current Implementation: PARTIALLY OPTIMAL

Issues Identified:

1. Write-Heavy Workload
      // CURRENT: Database write on EVERY API call
   llmclient.makerequest(...);
   apitracker.recordrequest(provider, tokens, model);  // INSERT
   
2. No Write Batching
   - Each API call = 1 database INSERT
   - For 100 files = 100 individual INSERTs
   - Heavy I/O overhead

Better Approach:

// OPTIMIZED: Batch writes with in-memory buffer
class APIUsageTracker {
private:
    std::vector<UsageRecord> pendingrecords;
    std::mutex pendingmutex;
    constexpr static sizet BATCHSIZE = 50;
    
    void recordrequest(provider, tokens, model) {
        std::lockguard<std::mutex> lock(pendingmutex);
        pendingrecords.pushback({provider, tokens, model, now()});
        
        if (pendingrecords.size() >= BATCHSIZE) {
            flushtodatabase();  // Single transaction for 50 records
        }
    }
    
    void flushtodatabase() {
        db.begintransaction();
        for (auto& record : pendingrecords) {
            db.insert(record);
        }
        db.commit();  // One commit for all records
        pendingrecords.clear();
    }
};

Recommendation:
- ⚠️ Add write batching: Buffer 50 records before database write
- ⚠️ Add periodic flush: Auto-flush every 60 seconds
- ⚠️ Flush on app exit: Ensure no data loss

---


--------------------------------------------------------------------------------
✅ OPTIMIZED: FILE TINDER DIALOG
--------------------------------------------------------------------------------


Current Implementation: GOOD

Why It's Optimal:
- Lazy loading (only current file loaded into memory)
- Keyboard-driven (no mouse overhead)
- Session state in database (proper persistence)
- Single-threaded UI (no race conditions)

Minor Enhancement Possible:
- Preload next 2-3 files in background (smoother experience)
- But current implementation is fine for most use cases

Recommendation: ✅ Keep as-is (or add prefetch as enhancement)

---


================================================================================
DATABASE SCHEMA ASSESSMENT
================================================================================


Current Design: Normalized relational model

Tables Added:
userprofiles
profilecharacteristics  
folderinsights
folderlearningsettings
apiusagetracking
filetinderstate
undohistory (enhanced)

Optimization Opportunities:

1. Add Indexes (CRITICAL for performance)
      -- Missing indexes that would help:
   CREATE INDEX idxapiusagedate ON apiusagetracking(date, provider);
   CREATE INDEX idxprofilechartype ON profilecharacteristics(characteristictype, confidence);
   CREATE INDEX idxfolderinsightspath ON folderinsights(folderpath);
   CREATE INDEX idxfolderlearningpath ON folderlearningsettings(folderpath);
   
2. Use Database Transactions
   - Batch multiple INSERTs into single transaction
   - 10-100x performance improvement

3. Consider Write-Ahead Log (WAL) Mode
      PRAGMA journalmode = WAL;
      - Better concurrency
   - Faster writes
   - No downside for this use case

---


================================================================================
MEMORY USAGE ASSESSMENT
================================================================================


Potential Issues:

1. UserProfileManager
   - Loads entire profile into memory on startup
   - For 1000+ folders, this could be 10+ MB
   - Solution: Lazy load folder insights

2. File Tinder
   - Loads all file paths into vector
   - For 100K files = ~10-20 MB
   - Current implementation is fine (paths are small)

---


================================================================================
THREADING & CONCURRENCY
================================================================================


Current State: Mostly single-threaded

Opportunities:
1. Parallel file categorization (not implemented)
   - Could process 4-8 files simultaneously
   - 3-5x speedup on multi-core systems
   
2. Background profile updates (recommended above)

3. Async database writes (recommended above)

---


================================================================================
RECOMMENDATIONS PRIORITY
================================================================================



--------------------------------------------------------------------------------
HIGH PRIORITY (PERFORMANCE IMPACT)
--------------------------------------------------------------------------------


1. Add Database Indexes
   - Impact: 10-100x query speedup
   - Effort: 5 minutes
   - Risk: None

2. Enable WAL Mode
   - Impact: 2-3x write speedup  
   - Effort: 1 line of code
   - Risk: None

3. Batch API Usage Tracking Writes
   - Impact: 50x fewer database operations
   - Effort: 2-3 hours
   - Risk: Low (need proper shutdown handling)


--------------------------------------------------------------------------------
MEDIUM PRIORITY (USER EXPERIENCE)
--------------------------------------------------------------------------------


4. Async Profile Analysis
   - Impact: Prevents UI freezing
   - Effort: 4-6 hours
   - Risk: Medium (threading complexity)

5. Reduce Gemini State File I/O
   - Impact: Faster API calls
   - Effort: 2-3 hours
   - Risk: Low


--------------------------------------------------------------------------------
LOW PRIORITY (NICE TO HAVE)
--------------------------------------------------------------------------------


6. Parallel File Categorization
   - Impact: 3-5x speedup for large batches
   - Effort: 1-2 weeks
   - Risk: High (complex threading, LLM coordination)

7. Lazy Load Profile Data
   - Impact: Faster startup
   - Effort: 4-6 hours
   - Risk: Low

---


================================================================================
CONCLUSION
================================================================================


Overall Assessment: The implementations are architecturally sound and follow Qt best practices. The main optimization opportunities are:

1. Database performance (indexes, WAL mode, batching)
2. Async operations (profile analysis, API tracking writes)
3. File I/O reduction (Gemini state persistence)

Current Code Quality: 7.5/10
With Optimizations: Would be 9/10

The foundations are solid - these are performance enhancements, not architectural problems.

